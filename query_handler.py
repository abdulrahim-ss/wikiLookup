import json
from typing import Tuple, Union, Any
import json

from aqt.gui_hooks import webview_did_receive_js_message
from aqt.reviewer import Reviewer
from aqt import mw

from .scraper import Scraper

class Query_Handler:
    def __init__(self):
        self.scraper = Scraper()
        webview_did_receive_js_message.append(self.handle_search_query)

    def handle_search_query(self, handled: tuple[bool, Any], message: str, context: Any) -> tuple[bool, Any]:
        """
            get search query from webviewer through pycmd (which is used by 'wikiLookup.js'),
            and send the search result (generated by 'matching_article()') to the webviewer as a JSON object
        """
        if not isinstance(context, Reviewer):
            return handled

        action = self.action(message)
        if not action: return handled
        result = self.scraper.matching_article()
        if not result: return handled

        response =  json.dumps(result)
        # For some reason I can't send the response as a value to pycmd()'s callback on the webviewer side
        # so I used a workaround method, which is to evaluate that a variable called "search_result" in the
        # webviewer's javascript code is equal to our response generated here.
        mw.web.eval(f"search_result = JSON.parse({response})")
        mw.web.eval(f"console.log(\"{message} received by the python side of the wikiLookup add-on\")")
        return (True, None)
    
    def action(self, message: str) -> Union[str, None]:
        msg = json.loads(message)
        if msg["action"] == "search":
            self.scraper.search(msg["message"])
        elif msg["action"] == "next":
            return "next"
        else:
            return None